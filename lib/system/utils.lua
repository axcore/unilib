---------------------------------------------------------------------------------------------------
-- unilib mod by A S Lewis, incorporating materials from many other mods
---------------------------------------------------------------------------------------------------
-- utils.lua
--      Set up utility functions for unilib development
---------------------------------------------------------------------------------------------------

local S = unilib.intllib

-- If creative is enabled for all players, then calls to unilib.is_creative() don't have to check on
--      a per-player basis
local creative_mode_cache = minetest.settings:get_bool("creative_mode")

---------------------------------------------------------------------------------------------------
-- Attribute functions
---------------------------------------------------------------------------------------------------

function unilib.get_mod_attribute(key)

    -- Retrieves the value of a key-value pair in mod storage
    --
    -- This function automatically adds "unilib:" to the beginning of the key, so the calling code
    --      shouldn't do that
    -- In order to guarantee their uniqueness, keys created by packages should begin
    --          "pkg_PACKAGENAME_". For keys generated by any other code, the first component should
    --          mirror the code's file name (e.g. "cuisine_" for keys created by
    --          ../lib/effects/cuisine.lua)
    --
    -- Args:
    --      key (str): A unique string. This function automatically adds "unilib:mattrib_" to the
    --          beginning of the key, so the calling code shouldn't do that
    --
    -- Return values:
    --      The key's corresponding value (always a string), or an empty string on failure

    key = "unilib:mattrib_" .. key
    return unilib.mod_storage:get_string(key) or ""

end

function unilib.set_mod_attribute(key, value)

    -- Stores a key-value pair in mod storage
    --
    -- This function automatically adds "unilib:" to the beginning of the key, so the calling code
    --      shouldn't do that
    -- In order to guarantee their uniqueness, keys created by packages should begin
    --          "pkg_PACKAGENAME_". For keys generated by any other code, the first component should
    --          mirror the code's file name (e.g. "cuisine_" for keys created by
    --          ../lib/effects/cuisine.lua)
    --
    -- Args:
    --      key (str): A unique string. This function automatically adds "unilib:mattrib_" to the
    --          beginning of the key, so the calling code shouldn't do that
    --      value (str): Non-string values are converted to strings; nil is converted to any empty
    --          string

    key = "unilib:mattrib_" .. key

    if value == nil then
        unilib.mod_storage:set_string(key, "")
    else
        unilib.mod_storage:set_string(key, tostring(value))
    end

end

function unilib.get_player_attribute(player, key)

    -- Retrieves the value of a key-value pair in the player's metadata
    --
    -- This function automatically adds "unilib:" to the beginning of the key, so the calling code
    --      shouldn't do that
    -- In order to guarantee their uniqueness, keys created by packages should begin
    --          "pkg_PACKAGENAME_". For keys generated by any other code, the first component should
    --          mirror the code's file name (e.g. "cuisine_" for keys created by
    --          ../lib/effects/cuisine.lua)
    --
    -- Args:
    --      player (Player): The player object
    --      key (str): A unique string. This function automatically adds "unilib:pattrib_" to the
    --          beginning of the key, so the calling code shouldn't do that
    --
    -- Return values:
    --      The key's corresponding value (always a string), or an empty string on failure

    key = "unilib:pattrib_" .. key

    local meta = player:get_meta()
    return meta and meta:get_string(key) or ""

end

function unilib.set_player_attribute(player, key, value)

    -- Stores a key-value pair in the player's metadata
    --
    -- This function automatically adds "unilib:" to the beginning of the key, so the calling code
    --      shouldn't do that
    -- In order to guarantee their uniqueness, keys created by packages should begin
    --          "pkg_PACKAGENAME_". For keys generated by any other code, the first component should
    --          mirror the code's file name (e.g. "cuisine_" for keys created by
    --          ../lib/effects/cuisine.lua)
    --
    -- Args:
    --      player (Player): The player object
    --      key (str): A unique string. This function automatically adds "unilib:pattrib_" to the
    --          beginning of the key, so the calling code shouldn't do that
    --      value (str): Non-string values are converted to strings; nil is converted to any empty
    --          string

    key = "unilib:pattrib_" .. key

    local meta = player:get_meta()
    if meta and value == nil then
        meta:set_string(key, "")
    elseif meta then
        meta:set_string(key, tostring(value))
    end

end

function unilib.deserialise_player_attribute(player, key)

    -- Deserialises the value of a key-value pair, before returning it
    --
    -- This function automatically adds "unilib:" to the beginning of the key, so the calling code
    --      shouldn't do that
    -- In order to guarantee their uniqueness, keys created by packages should begin
    --          "pkg_PACKAGENAME_". For keys generated by any other code, the first component should
    --          mirror the code's file name (e.g. "cuisine_" for keys created by
    --          ../lib/effects/cuisine.lua)
    --
    -- Args:
    --      player (Player): The player object
    --      key (str): A unique string. This function automatically adds "unilib:pattrib_" to the
    --          beginning of the key, so the calling code shouldn't do that
    --
    -- Return values:
    --      The key's corresponding value (always a table), or an empty table on failure

    key = "unilib:pattrib_" .. key

    local meta = player:get_meta()
    return meta and minetest.deserialize(meta:get_string(key), true) or {}

end

function unilib.serialise_player_attribute(player, key, data_table)

    -- Serialises the value of a key-value pair, before storing it in the player's metadata
    --
    -- This function automatically adds "unilib:" to the beginning of the key, so the calling code
    --      shouldn't do that
    -- In order to guarantee their uniqueness, keys created by packages should begin
    --          "pkg_PACKAGENAME_". For keys generated by any other code, the first component should
    --          mirror the code's file name (e.g. "cuisine_" for keys created by
    --          ../lib/effects/cuisine.lua)
    --
    -- Args:
    --      player (Player): The player object
    --      key (str): A unique string. This function automatically adds "unilib:pattrib_" to the
    --          beginning of the key, so the calling code shouldn't do that
    --      data_table (table): A table containing tables, strings, numbers, booleans and nils

    key = "unilib:pattrib_" .. key

    local meta = player:get_meta()
    if meta then
        meta:set_string(key, minetest.serialize(data_table))
    end

end

---------------------------------------------------------------------------------------------------
-- biome/decoration/ore functions
---------------------------------------------------------------------------------------------------

function unilib.check_heights(y_max, y_min)

    -- Unique to unilib
    -- Call by biome/decoration/ore registration code to check that two values for a maximum/
    --      minimum height are valid
    -- Either or both of the arguments may be nil; this is considered a valid value
    -- Returns true for valid (or nil) values; false for any invalid value

    if (y_max ~= nil and y_max > unilib.y_max) or
            (y_min ~= nil and y_min < unilib.y_min) or
            (y_max ~= nil and y_min ~= nil and y_max < y_min) then
        return false
    else
        return true
    end

end

function unilib.get_height_constants()

    -- Called by ../system/read_csv.lua, or by any other code which wants to read a constanst.csv
    --      file in ../csvs

    return {
        X_MAX = unilib.x_max,
        X_MIN = unilib.x_min,
        Y_MAX = unilib.y_max,
        Y_MIN = unilib.y_min,
        Z_MAX = unilib.z_max,
        Z_MIN = unilib.z_min,
    }

end

function unilib.get_unique_deco_name(deco_name)

    -- Avoid duplicate decoration names, otherwise this decoration will overwrite a previously-
    --      defined decoration
    -- In schematic decorations, also replaces the opening "unilib_" with "unilib:", for consistency
    --      with simple decorations
    --
    -- Args:
    --      deco_name (str): The decoration's proposed name
    --
    -- Return values:
    --      Returns "deco_name" unmodified if it's available, otherwise returns a name in the form
    --          deco_name_alt_N

    -- "simple" decorations tend to be in the form "unilib:xxx", whereas schematics tend to be in
    --      the form "unilib_xxx". Switch out the underline for consistency
    deco_name = string.gsub(deco_name, "^unilib_", "unilib:")

    if minetest.registered_decorations[deco_name] == nil then
        return deco_name
    end

    local count = 1
    while(true) do

        count = count + 1
        local alt_name = deco_name .. "_alt_" .. tostring(count)
        if minetest.registered_decorations[alt_name] == nil then
            return alt_name
        end

    end

end

---------------------------------------------------------------------------------------------------
-- biome_lib conversion functions
---------------------------------------------------------------------------------------------------

function unilib.convert_biome_lib(data_table)

    -- Code to convert biome_lib values, typically used in a call to
    --      biome_lib.register_on_generate(), into a probability in the range 0-1
    -- The returned value can be used as the .fill_ratio in a minetest.register_decoration() call
    --
    -- This algorithm should create decorations with approximately the same frequency as
    --      biome_lib itself does (and if not, the algorithm can be updated without needing to
    --      update the calling packages)
    -- For some example code, see the "bush_branching_yellow" package

    -- Range of 0-100. Larger values make objects more rare
    local rarity = data_table.rarity or 100
    -- Rarity is reduced by fertility, i.e. (rarity - rarity_fertility)
    local rarity_fertility = data_table.rarity_fertility or 0
    -- Range of -1 to +1, with values in the range of about 0 to 0.5 being most useful
    local plantlife_limit = data_table.plantlife_limit or 0.1

    return (1 / (rarity - rarity_fertility)) *
            ((2 - (1 + plantlife_limit)) / 2) *
            unilib.biome_lib_spawn_factor

end

function unilib.convert_biome_lib_humidity(humidity)

    -- Code to convert biome_lib humidity values in the range +1 (0% humidity) to -1 (100% humidity)
    --      into a value in the range 0 (0% humidity) to 100 (100% humidity)
    -- The returned value can be used in a call to unilib.register_decoration_convertable()

    return (2 - (humidity + 1)) * 50

end

function unilib.convert_biome_lib_temp(temp)

    -- Code to convert biome_lib temperature values in the range +1 (maximum coldness) to -1
    --      (maximum heat) into a value in the range 0 (maximum coldness) to 100 (maximum heat)
    -- The returned value can be used in a call to unilib.register_decoration_convertable()

    return (2 - (temp + 1)) * 50

end

---------------------------------------------------------------------------------------------------
-- CSV conversion functions
---------------------------------------------------------------------------------------------------

function unilib.read_csv(path, separator)

    -- Adapted from code in various mods, written by Gael-de-Sailly
    -- Reads an arbitrary CSV file, returning its contents as a table
    --
    -- Args:
    --      path (str): The file path to read
    --      separator (str or nil): Any separator may be specified, but unilib uses the | character
    --          as standard. If not specified, then the standard separator is used
    --
    -- Return values
    --      t (table): The file's data arranged in a table, one line per item

    if separator == nil then
        separator = unilib.separator
    end

    local file = io.open(path, "r")
    local t = {}

    for line in file:lines() do

        -- Strip trailing newline/whitespace characters
        local adj_line = line:gsub("[ \t\r\n]+$", "")

        -- So that error messages can display the correct line number, any ignorable line is
        --      represented by an empty table
        if adj_line:sub(1, 1) ~= "#" and adj_line:find("[^%" .. separator .. "% ]") then
            table.insert(t, adj_line:split(separator, true))
        else
            table.insert(t, {})
        end

    end

    return t

end

---------------------------------------------------------------------------------------------------
-- Date/time functions
---------------------------------------------------------------------------------------------------

function unilib.format_time(seconds)

    seconds = math.floor(seconds)

    local days = math.floor(seconds / (60 * 60 * 24))
    seconds = seconds % (60 * 60 * 24)

    local hours = math.floor(seconds / (60 * 60))
    seconds = seconds % (60 * 60)

    local minutes = math.floor(seconds / 60)
    seconds = seconds % 60

    local format_string = ""
    if days ~= nil and days ~= 0 then

        if days == 1 then
            format_string = S("1 day")
        else
            format_string = S("@1 days", days)
        end

    end

    if hours ~= nil and hours ~= 0 then

        if format_string ~= "" then
            format_string = format_string .. ", "
        end

        if hours == 1 then
            format_string = format_string .. S("1 hour")
        else
            format_string = format_string .. S("@1 hours", hours)
        end

    end

    if minutes ~= nil and minutes ~= 0 then

        if format_string ~= "" then
            format_string = format_string .. ", "
        end

        if minutes == 1 then
            format_string = format_string .. S("1 minute")
        else
            format_string = format_string .. S("@1 minutes", minutes)
        end

    end

    if format_string ~= "" then
        format_string = format_string .. ", "
    end

    if seconds == 1 then
        format_string = format_string .. S("1 second")
    else
        format_string = format_string .. S("@1 seconds", seconds)
    end

    return format_string

end

function unilib.get_clock_time()

    local t = minetest.get_timeofday()
    local h = math.floor(t * 24) % 24
    local m = math.floor(t * 1440) % 60

    return string.format("%02d", h) .. ":" .. string.format("%02d", m), h, m

end

---------------------------------------------------------------------------------------------------
-- Description/infotext functions
---------------------------------------------------------------------------------------------------

function unilib.annotate(text, extra)

    -- Code adapted from aotearoa
    -- Call this function to modify some uncolourised text, by adding add a scientific name (in
    --      a standard colour, and on a new line)
    -- Stylistic considerations: "extra" should follow the normal rules for scientific
    --      capitalisation, e.g. "Populus tremula"

    if extra == nil then
        return text
    else
        return text .. "\n" .. minetest.colorize("#ADABA0", "(" .. extra .. ")")
    end

end

function unilib.brackets(text, extra)

    -- Original to unilib
    -- Call this function to append some text, in brackets
    -- Stylistic considerations: both "text" and "extra" should be capitalised, e.g.
    --      "Door", "Open"
    -- (Exception: for stairs and carvings, only the first word of "extra" is usually capitalised)
    -- (Exception: a mod or package name need not be capitalised)

    if extra == nil then
        return text
    else
        return text .. " (" .. extra .. ")"
    end

end

function unilib.emphasise(extra)

    -- Original to unilib
    -- Call this function to colourise some text in bright yellow (thus "emphasising" it)

    if extra == nil then
        return extra
    else
        return minetest.colorize("#FFFF00", extra)
    end

end

function unilib.hint(text, extra)

    -- Original to unilib
    -- Call this function to modify some uncolourised text, by adding add a hint (in a standard
    --      colour, and on a new line)
    -- Stylistic considerations: "text" should be capitalised, but "extra" should be in mostly
    --      lower-case

    if extra == nil then
        return text
    else
        return text .. "\n" .. minetest.colorize("#006633", "(" .. extra .. ")")
    end

end

---------------------------------------------------------------------------------------------------
-- File functions
---------------------------------------------------------------------------------------------------

function unilib.is_file(path)

    -- Adapted from https://stackoverflow.com/questions/4990990/check-if-a-file-exists-with-lua
    -- Checks whether the specified file path actually exists, or not
    --
    -- Args:
    --      path (nil or str): The file path to check
    --
    -- Return values:
    --      true if the path exists, false if not

    -- Sanity check
    if path == nil or path == "" then
        return false
    end

    local fh = io.open(path, "r")
    if fh ~= nil then
        io.close(fh)
        return true
    else
        return false
    end

end

---------------------------------------------------------------------------------------------------
-- List/table functions
---------------------------------------------------------------------------------------------------

function unilib.clone_simple_table(data_table)

    -- Assumes a simple key/value table structure, for example one used in the .groups field of a
    --      minetest.register_node() call

    local t = {}
    for k, v in pairs(data_table) do
        t[k] = v
    end

    return t

end

function unilib.convert_to_list(arg)

    -- "arg" is expected to be either nil, a string, or a list
    -- Returns a list (the original one, or a list containing the string, or an empty list)
    -- Note that, when "arg" is nil or an empty string, then returns an empty list

    if type(arg) == "table" then

        -- Already a list
        return arg

    elseif arg == nil or arg == "" then

        -- For nil/empty strings, return an empty list
        return {}

    else

        -- Convert the string to a list
        return { arg }

    end

end

function unilib.convert_to_string(arg)

    -- "arg" is expected to be either nil, a scalar value, a list, or a list of lists (but not a
    --      table)
    -- If a list of lists, then a mixture of mini-lists and scalar values is acceptable, e.g.
    --      { {a, b, c}, d, {e, f, g} }
    -- Returns "arg" converted to a string (if originally a list, concatenated as a string)

    if type(arg) == "table" then

        local str = ""
        for _, value in ipairs(arg) do

            if type(value) ~= "table" then

                if str == "" then
                    str = value
                else
                    str = str .. ", " .. value
                end

            else

                local mini_str = ""
                for _, this_value in pairs(value) do

                    if mini_str == "" then
                        mini_str = "{" .. this_value
                    else
                        mini_str = mini_str .. ", " .. this_value
                    end

                end

                if mini_str ~= "" then

                    mini_str = mini_str .. "}"
                    if str == "" then
                        str = mini_str
                    else
                        str = str .. ", " .. mini_str
                    end

                end

            end

        end

        return str

    else

        return tostring(arg)

    end

end

function unilib.is_table_empty(t)

    -- Although the "correct" way to check for an empty lua table is
    --      if not next(table) then
    -- ..., a call to this function clarifies that the calling code is actually checking for an
    --      empty table, and not just testing whether the value is nil, or not

    for _, _ in pairs(t) do
        return false
    end

    return true

end

function unilib.is_value_in_list(arg, list)

    -- Checks whether an argument appears in a list (sequential table), or not
    --
    -- Args:
    --      arg (any): The item to check
    --      list (list): The list to check
    --
    -- Return values:
    --      true if arg appears in list, false if not

    for _, v in ipairs(list) do
        if arg == v then
            return true
        end
    end

    return false

end

function unilib.is_value_scalar_or_in_list(arg, value)

    -- Checks whether an argument matches a scalar value, or appears in a list value (sequential
    --      table)
    --
    -- Args:
    --      arg (any): The item to check
    --      value (scalar or list): The matching item to check

    if type(value) == "table" then
        return unilib.is_value_in_list(arg, value)
    elseif arg == value then
        return true
    else
        return false
    end

end

local function prepare_table(t, indent)

    if not indent then
        indent = 0
    end

    local toprint = "{\r\n"
    indent = indent + 4
    for k, v in pairs(t) do

        toprint = toprint .. string.rep(" ", indent)
        if (type(k) == "number") then
            toprint = toprint .. "[" .. k .. "] = "
        elseif (type(k) == "string") then
            toprint = toprint .. k ..  " = "
        end

        if v == false then
            toprint = toprint .. "false,\r\n"
        elseif v == true then
            toprint = toprint .. "true,\r\n"
        elseif (type(v) == "number") then
            toprint = toprint .. v .. ",\r\n"
        elseif (type(v) == "string") then
            toprint = toprint .. "\"" .. v .. "\",\r\n"
        elseif (type(v) == "table") then
            toprint = toprint .. prepare_table(v, indent) .. ",\r\n"
        else
            toprint = toprint .. "\"" .. tostring(v) .. "\",\r\n"
        end

    end

    toprint = toprint .. string.rep(" ", indent - 4) .. "}"

    return toprint

end

function unilib.show_table(t, title)

    -- Adapted from https://stackoverflow.com/questions/41942289/display-contents-of-tables-in-lua
    -- Formats a table for display. The output looks better in Minetest's debug.txt file, but is
    --      readable in the chat window
    --
    -- Args:
    --      t (table): The table to display
    --
    -- Optional args:
    --      title (str): A title to display, if required

    -- Sanity checks
    if type(t) ~= "table" then

        unilib.show_error("unilib.print_table(): Cannot print this data type as a table")
        return

    end

    -- Print the table
    local output = "\r\n"
    if title ~= nil and title ~= "" then
        output = output .. title .. "\r\n"
    end

    output = output .. prepare_table(t)

    minetest.log(output)

end

function unilib.show_table_in_chat(pname, t, title)

    -- Modified version of unilib.show_table, for use with chat commands
    -- This version uses minetest.chat_send_player() instead of minetest.log()
    --
    -- THIS FUNCTION SHOULD NOT BE CALLED DURING STARTUP, as no players will be connected. If
    --      necessary, you could do this:
    --
    --          local function foobar()
    --              for i, player in ipairs(minetest.get_connected_players()) do
    --                  local pname = player:get_player_name()
    --                  unilib.show_table_in_chat(pname, TABLE)
    --              end
    --          end
    --
    --          minetest.after(1, foobar)
    --
    -- Args:
    --      pname (str): The player's name
    --      t (table): The table to display
    --
    -- Optional args:
    --      title (str): A title to display, if required

    -- Sanity checks
    if type(t) ~= "table" then

        minetest.chat_send_player(
            pname,
            string.format("Cannot print the data type %s as a table", type(t))
        )

        return

    end

    -- Print the table
    local output = "\r\n"
    if title ~= nil and title ~= "" then
        output = output .. title .. "\r\n"
    end

    output = output .. prepare_table(t)

    minetest.chat_send_player(pname, output)

end

function unilib.sort_table(t)

    local list = {}
    for key in pairs(t) do
        table.insert(list, key)
    end

    table.sort(list)

    return list

end

function unilib.test_equivalence_of_lists(list1, list2)

    -- Test equivalence of two lists
    --
    -- Args:
    --      list1, list2 (table): The lists to compare
    --
    -- Return values:
    --      If at least one value appears in both lists, returns true. Otherwise returns false

    local table1 = {}
    for _, v in ipairs(unilib.convert_to_list(list1)) do
        table1[v] = true
    end

    local table2 = {}
    for _, v in ipairs(unilib.convert_to_list(list2)) do
        table2[v] = true
    end

    for k, _ in pairs(table1) do

        if table2[k] == nil then

            -- list1 contains values not in list2
            return false

        else

            table2[k] = nil

        end

    end

    if not unilib.is_table_empty(table2) then

        -- list2 contains values not in list1
        return false

    else

        -- list1, list2 are equivalent
        return true

    end

end

function unilib.test_junction_of_lists(list1, list2)

    -- Test junction of two lists
    --
    -- Args:
    --      list1, list2 (table): The lists to compare
    --
    -- Return values:
    --      If at least one value appears in both lists, returns true. Otherwise returns false

    local adj_list1 = unilib.convert_to_list(list1)
    local adj_list2 = unilib.convert_to_list(list2)

    for _, value1 in ipairs(adj_list1) do

        for _, value2 in ipairs(adj_list2) do

            if value1 == value2 then
                return true
            end

        end

    end

    return false

end

---------------------------------------------------------------------------------------------------
-- Log functions
---------------------------------------------------------------------------------------------------

local function format_log_args(arg1, arg2, arg3)

    -- Information, error and warning messages written to minetest.log() can have up to two optional
    --      arguments. This function returns a nicely-formatted string (or an empty one)

    local str = ""

    if arg1 ~= nil then

        str = ": " .. unilib.convert_to_string(arg1)
        if arg2 ~= nil then

            str = str .. " / " .. unilib.convert_to_string(arg2)
            if arg3 ~= nil then

                str = str .. " / " .. unilib.convert_to_string(arg3)

            end

        end

    end

    return str

end

function unilib.show_msg(msg, arg1, arg2, arg3)

    -- Code should call this function, instead of calling minetest.log() directly
    -- The message is not displayed if unilib.show_msg_flag is not set
    --
    -- Args:
    --      msg (str): The message to display
    --
    -- Optional args:
    --      arg1, arg2, arg3 (any): Optional arguments which, if specified, are converted to strings
    --          and displayed below the main message

    if unilib.show_msg_flag then
        minetest.log(unilib.info_header .. msg .. format_log_args(arg1, arg2, arg3))
    end

end

function unilib.show_error(msg, arg1, arg2, arg3)

    -- Code should call this function, instead of calling minetest.log() directly
    -- The message is not displayed if unilib.show_error_flag is not set
    --
    -- Args:
    --      msg (str): The error message to display
    --
    -- Optional args:
    --      arg1, arg2, arg3 (any): Optional arguments which, if specified, are converted to strings
    --          and displayed below the error message

    if unilib.show_error_flag then
        minetest.log(unilib.error_header .. msg .. format_log_args(arg1, arg2, arg3))
    end

end

function unilib.show_warning(msg, arg1, arg2, arg3)

    -- Code should call this function, instead of calling minetest.log() directly
    -- The message is not displayed if unilib.show_warning_flag is not set
    --
    -- Args:
    --      msg (str): The message to display
    --
    -- Optional args:
    --      arg1, arg2, arg3 (any): Optional arguments which, if specified, are converted to strings
    --          and displayed below the warning message

    if unilib.show_warning_flag then
        minetest.log(unilib.warning_header .. msg .. format_log_args(arg1, arg2, arg3))
    end

end

function unilib.log(category, msg)

    -- This function exists so that, during debugging, the developer can insert temporary
    --      minetest.log() calls, and then later easily find them to remove them
    -- In contrast, calls to this function are regarded as permanent
    --
    -- Args:
    --      category (str): The minetest.log() level. As of Minetest v5.4.1, "none" (default),
    --          "error", "warning", "action", "info", or "verbose"`
    --      msg (str): The message to log

    minetest.log(category, msg)

end

---------------------------------------------------------------------------------------------------
-- Minetest functions
---------------------------------------------------------------------------------------------------

function unilib.get_pointed_node(player)

    -- Adapted from what_is_this_uwu.get_pointed_thing()
    -- Returns the node object, or nil when not pointing at a node
    -- For an example of some calling code, see ../lib/effects/identify.lua

    -- Get player position
    local player_pos = player:get_pos()
    local eye_height = player:get_properties().eye_height
    local eye_offset = player:get_eye_offset()
    player_pos.y = player_pos.y + eye_height
    player_pos = vector.add(player_pos, eye_offset)

    -- Set vision in liquids
    local see_liquid
            = minetest.registered_nodes[minetest.get_node(player_pos).name].drawtype ~= "liquid"

    -- Get wielded item range 5; is the engine default
    -- order tool/item range >> hand_range >> fallback 5
    local tool_range = player:get_wielded_item():get_definition().range or nil
    local hand_range

    for key, val in pairs(minetest.registered_items) do

        if key == "" then
            hand_range = val.range or nil
        end
    end

    local wield_range = tool_range or hand_range or 5

    -- Determine ray end position
    local look_dir = player:get_look_dir()
    look_dir = vector.multiply(look_dir, wield_range)
    local end_pos = vector.add(look_dir, player_pos)

    -- Get pointed_thing
    local ray = minetest.raycast(player_pos, end_pos, false, see_liquid)
    local pointed_thing = ray:next()
    if pointed_thing then
        return minetest.get_node(pointed_thing.under)
    else
        return nil
    end

end

function unilib.is_creative(player_name)

    -- Adapted from farming_redo/init.lua
    -- Checks creative mode on a per-player basis (if a player name is specified), or for all
    --      players otherwise (checking the Minetest "creative_mode" setting)
    --
    -- All unilib code should call this function, rather than minetest.is_creative_enabled()
    --
    -- Args:
    --      player_name (str or "" or nil): The optional player name, e.g. "singleplayer"

    if player_name == nil or player_name == "" then
        return creative_mode_cache
    else
        return creative_mode_cache or minetest.check_player_privs(player_name, {creative = true})
    end

end

---------------------------------------------------------------------------------------------------
-- Miscellaneous functions
---------------------------------------------------------------------------------------------------

function unilib.get_random_seed()

    -- Return values
    --      A random value in the range -32768 to 32767 (an arbitrary range of integers)

    return math.random(-32768, 32767)

end

function unilib.prune_fishing_list(list)

    -- Three global variables provide lists of items that can be caught by a fishing rod
    -- This function is passed one of those lists
    -- Returns a modified list, with any item which doesn't exist (or which is associated with a
    --      biome or fishing rod that doesn't exist) removed
    --
    -- Args:
    --      list (list): The list to check
    --
    -- Return values:
    --      The modified list


    local mod_list = {}
    for _, mini_table in ipairs(list) do

        if (
            mini_table.full_name ~= nil and
            (
                minetest.registered_nodes[mini_table.full_name] ~= nil or
                minetest.registered_craftitems[mini_table.full_name] ~= nil or
                minetest.registered_tools[mini_table.full_name] ~= nil
            )
        ) and
        (mini_table.biome_name == nil or unilib.biome_table[mini_table.biome_name] ~= nil) and
        (mini_table.rod_name == nil or minetest.registered_nodes[mini_table.rod_name] ~= nil) then
            table.insert(mod_list, mini_table)
        end

    end

    return mod_list

end

function unilib.set_auto_rotate(full_name, flag)

    -- Original to unilib
    -- Call for any block to which auto-rotation should be applied, or not, depending on some
    --      setting (typically tree wood nodes and brick block nodes)
    --
    -- Args:
    --      full_name (str): e.g. "unilib:tree_aspen_wood"
    --      flag (bool): True to auto-rotate the block in a standard direction, false otherwise

    if not flag then

        unilib.override_item(full_name, {
            paramtype2 = "facedir",

            on_place = minetest.rotate_node,
        })

    else

        unilib.override_item(full_name, {
            paramtype2 = "facedir",
            place_param2 = 0,
        })

    end

end

---------------------------------------------------------------------------------------------------
-- Node/craftitem/tool functions
---------------------------------------------------------------------------------------------------

function unilib.get_craftitem_field(full_name, field_name)

    -- Adapted from biome_lib/api.lua
    --
    -- Args:
    --      full_name (str): e.g. "unilib:mineral_coal_lump"
    --      field_name (str): e.g. "description"
    --
    -- Return values:
    --      Returns the value of the field, or nil if either the node or the field do not exist

    if not minetest.registered_craftitems[full_name] then
        return nil
    else
        return minetest.registered_craftitems[full_name][field_name]
    end

end

function unilib.get_definition_and_group(full_name, group)

    -- Original to unilib
    -- Wrapper for unilib.get_group() when it's not known whether the item "full_name" is a node,
    --      craftitem or tool
    -- If the specified item's definition table contains the specified group, return its number;
    --      otherwise return 0

    if minetest.registered_nodes[full_name] ~= nil then
        return unilib.get_group(minetest.registered_nodes[full_name], group)
    elseif minetest.registered_craftitems[full_name] ~= nil then
        return unilib.get_group(minetest.registered_craftitems[full_name], group)
    elseif minetest.registered_tools[full_name] ~= nil then
        return unilib.get_group(minetest.registered_tools[full_name], group)
    else
        return 0
    end

end

function unilib.get_group(def_table, group)

    -- Adapted from sickles/api.lua
    -- If the specified item's definition table contains the specified group, return its number;
    --      otherwise return 0

    if def_table == nil or
            def_table.groups == nil or
            def_table.groups[group] == nil then
        return 0
    else
        return def_table.groups[group]
    end

end

function unilib.get_node_field(full_name, field_name)

    -- Adapted from biome_lib/api.lua
    --
    -- Args:
    --      full_name (str): e.g. "unilib:stone_ordinary"
    --      field_name (str): e.g. "description"
    --
    -- Return values:
    --      Returns the value of the field, or nil if either the node or the field do not exist

    if not minetest.registered_nodes[full_name] then
        return nil
    else
        return minetest.registered_nodes[full_name][field_name]
    end

end

function unilib.get_tool_field(full_name, field_name)

    -- Adapted from biome_lib/api.lua
    --
    -- Args:
    --      full_name (str): e.g. "unilib:tool_pick_steel"
    --      field_name (str): e.g. "description"
    --
    -- Return values:
    --      Returns the value of the field, or nil if either the node or the field do not exist

    if not minetest.registered_tools[full_name] then
        return nil
    else
        return minetest.registered_tools[full_name][field_name]
    end

end

function unilib.is_registered_node_or_mtgame_alias(arg)

    -- Original to unilib
    -- Intended for code creating biomes, custom dirts, decorations, ores, etc, when the replace
    --      mode for minetest_game mods is "defer" (meaning that default:dirt exists in the world,
    --      rather than the expected unilib:dirt_ordinary)
    -- Checks whether unilib node(s) exist, or whether their minetest_game equivalents exist
    -- (The magic of Minetest aliases will take care of the rest, allowing us for example to create
    --      an ore whose .ore field is a minetest_game node, and whose .wherein field is a unilib
    --      node)
    --
    -- Args:
    --      arg (str or list): One or more nodes
    --
    -- Return values:
    --      true if all the specified nodes exist, false if at least one of them does not, false if
    --          the argument is nil

    if arg == nil then
        return false
    end

    for _, full_name in pairs(unilib.convert_to_list(arg)) do

        if minetest.registered_nodes[full_name] == nil and (
            unilib.mtgame_deconvert_table[full_name] == nil or
            minetest.registered_nodes[unilib.mtgame_deconvert_table[full_name]] == nil
        ) then
            return false
        end

    end

    return true

end

---------------------------------------------------------------------------------------------------
-- Node/craftitem/tool functions (item names)
---------------------------------------------------------------------------------------------------

function unilib.convert_item(full_name)

    -- Converts the name of a node, craftitem or tool from another mod to the unilib equivalent, if
    --      possible
    -- Filters out any items that are unregistered with Minetest, or which unilib has marked as
    --      hidden
    --
    -- Args:
    --      full_name (str): e.g. "unilib:stone_ordinary"
    --
    -- Return values:
    --      Returns the unilib name (as a string, or nil if no item exists) and the original mod's
    --          names (as a list, which might be empty)

    local unilib_name = nil
    local orig_name_list = {}

    if unilib.node_convert_table[full_name] ~= nil then

        unilib_name = unilib.node_convert_table[full_name]
        orig_name_list = unilib.node_deconvert_table[unilib_name]

    elseif unilib.node_deconvert_table[full_name] ~= nil then

        unilib_name = full_name
        orig_name_list = unilib.node_deconvert_table[unilib_name]

    elseif unilib.craftitem_convert_table[full_name] ~= nil then

        unilib_name = unilib.craftitem_convert_table[full_name]
        orig_name_list = unilib.craftitem_deconvert_table[unilib_name]

    elseif unilib.craftitem_deconvert_table[full_name] ~= nil then

        unilib_name = full_name
        orig_name_list = unilib.craftitem_deconvert_table[unilib_name]

    elseif unilib.tool_convert_table[full_name] ~= nil then

        unilib_name = unilib.tool_convert_table[full_name]
        orig_name_list = unilib.tool_deconvert_table[unilib_name]

    elseif unilib.craftitem_deconvert_table[full_name] ~= nil then

        unilib_name = full_name
        orig_name_list = unilib.tool_deconvert_table[unilib_name]

    elseif unilib.get_mod_name(full_name) == "unilib" then

        unilib_name = full_name

    else

        orig_name_list = {full_name}
    end

    -- Filter out any items which are hidden or not registered with Minetest
    if unilib_name and minetest.registered_items[unilib_name] == nil then
        unilib_name = nil
    end

    local adj_orig_name_list = {}
    for _, orig_name in pairs(orig_name_list) do

        if minetest.registered_items[orig_name] ~= nil and
                unilib.hidden_item_table[orig_name] == nil then

            table.insert(adj_orig_name_list, orig_name)

        end

    end

    return unilib_name, adj_orig_name_list

end

function unilib.split_name(full_name)

    -- Extracts the mod name and item name from a a full node/craftitem/tool name, returning them
    --      as a list
    --
    -- Args:
    --      full_name (str): e.g. "unilib:stone_ordinary"
    --
    -- Return values:
    --      e.g. { "unilib", "stone_ordinary" }, or an empty list full_name is not in the expected
    --          format

    -- Sanity check
    if full_name == nil or not string.find(full_name, ":") then
        return ""
    end

    local split_list = full_name:split(":")
    return split_list[1], split_list[2]

end

function unilib.get_mod_name(full_name)

    -- Extracts a mod name from a full node/craftitem/tool name
    --
    -- Args:
    --      full_name (str): e.g. "unilib:stone_ordinary"
    --
    -- Return values:
    --      e.g. "unilib", or an empty string if full_name is not in the expected format

    -- Sanity check
    if full_name == nil or not string.find(full_name, ":") then
        return ""
    end

    return full_name:split(":")[1]

end

function unilib.get_item_name(full_name)

    -- Extracts a mod name from a full node/craftitem/tool name
    --
    -- Args:
    --      full_name (str): e.g. "unilib:stone_ordinary"
    --
    -- Return values:
    --      e.g. "stone_ordinary", or an empty string if full_name is not in the expected format

    -- Sanity check
    if full_name == nil then
        return ""
    end

    return full_name:split(":")[2]

end

function unilib.get_first_component(full_name)

    -- Extracts the first component of a full node/craftitem/tool name
    --
    -- Args:
    --      full_name (str): e.g. "unilib:stone_ordinary"
    --
    -- Return values:
    --      e.g. "stone", or an empty string if full_name is not in the expected format

    -- Sanity check
    if full_name == nil then
        return ""
    end

    local mod_name = string.gsub(full_name, "^[^:]+:([^_]+)_.*", "%1")
    if mod_name == full_name then
        return ""
    else
        return mod_name
    end

end

function unilib.get_last_component(full_name)

    -- Extracts the last component of a full node/craftitem/tool name
    --
    -- Args:
    --      full_name (str): e.g. "unilib:stone_ordinary"
    --
    -- Return values:
    --      e.g. "ordinary", or an empty string if full_name is not in the expected format

    -- Sanity check
    if full_name == nil then
        return ""
    end

    local mod_name = string.gsub(full_name, "^.*_([^_]+)$", "%1")
    if mod_name == full_name then
        return ""
    else
        return mod_name
    end

end

function unilib.get_item_and_multiple(item_str)

    -- Expects an item string with an optional quantity, e.g. "unilib:stone_ordinary" or
    --      "unilib:stone_ordinary 9"
    -- If the quantity is not specified, it is assumed to be 1
    --
    -- Args:
    --  item_str (str): The string described above
    --
    -- Return values:
    --      Returns two values: the full name of the item (a string), and its quantity (an integer)

    local full_name, multiple

    if string.find(item_str, "^[^%s]+%s+%d+$") then

        full_name = string.gsub(item_str, "^([^%s]+)%s+%d+$", "%1")
        multiple = string.gsub(item_str, "^.*%s+(%d+)$", "%1")

    else

        full_name = item_str
        multiple = 1

    end

    return full_name, tonumber(multiple)

end

---------------------------------------------------------------------------------------------------
-- Numeric/string functions
---------------------------------------------------------------------------------------------------

function unilib.contract_long_lines(arg, max_length)

    -- arg is a long string, possible including newline characters
    -- This function reduces the length of each "line" in the string, replacing the missing text
    --      with an ellipsis

    if max_length == nil or max_length < 4 then
        max_length = 40
    end

    local line_list = {}

    for line in string.gmatch(arg, "([^\n]+)") do

        if string.len(line) <= max_length then
            table.insert(line_list, line)
        else
            table.insert(line_list, string.sub(line, 1, (max_length - 3)) .. "...")
        end

    end

    return table.concat(line_list, "\n")

end

function unilib.first_to_upper(arg)

    return (arg:gsub("^%l", string.upper))

end

function unilib.get_first_line(arg)

    local result = string.match(arg, "^[^\n]+")
    if result then
        return result
    else
        return arg
    end

end

function unilib.round_up(num, dp)

    -- Adapted from
    --      https://stackoverflow.com/questions/57950030/wow-rounding-to-two-decimal-places-in-lua
    -- Rounds up a number
    --
    -- Args:
    --      num (float): The number to round up
    --      dp (int): Can be negative, e.g. -1 rounds the number to the nearest 10

    local mult = 10 ^ (dp or 0)
    return math.floor((num * mult) + 0.5) / mult

end

function unilib.split_string_by_underline(arg, no_duplicate_flag)

    -- Modified version of unilib.split_string_by_whitespace(), splitting a string by underlines
    --      (underscores)
    --
    -- Args:
    --      arg (str): The string to split
    --      no_duplicate_flag (bool): If true, duplicate words are eliminated
    --
    -- Return values:
    --      The list of words (which may be empty)

    local list = {}
    local check_table = {}

    -- Sanity check
    if arg == nil or arg == "" then
        return list
    end

    -- Strip leading/trailing whitespace...
    arg = unilib.strip_whitespace(arg)
    -- ... then split the string by intermediate whitespace
    for word in string.gmatch(arg, "[^_]+") do

        if not no_duplicate_flag or check_table[word] == nil then

            table.insert(list, word)
            check_table[word] = ""

        end

    end

    return list

end

function unilib.split_string_by_whitespace(arg, no_duplicate_flag)

    -- Splits a string into a list. Each item in the return list is a single word
    -- Text like "stone_ordinary" counts as a single word, but "stone ordinary" counts as two
    -- If the string is nil or an empty string, returns an empty list
    --
    -- Args:
    --      arg (str): The string to split
    --      no_duplicate_flag (bool): If true, duplicate words are eliminated
    --
    -- Return values:
    --      The list of words (which may be empty)

    local list = {}
    local check_table = {}

    -- Sanity check
    if arg == nil or arg == "" then
        return list
    end

    -- Strip leading/trailing whitespace...
    arg = unilib.strip_whitespace(arg)
    -- ... then split the string by intermediate whitespace
    for word in string.gmatch(arg, "%S+") do

        if not no_duplicate_flag or check_table[word] == nil then

            table.insert(list, word)
            check_table[word] = ""

        end

    end

    return list

end

function unilib.strip_whitespace(arg)

    arg = arg:gsub("^%s+", "")
    arg = arg:gsub("%s+$", "")
    return arg

end

---------------------------------------------------------------------------------------------------
-- Setup functions
---------------------------------------------------------------------------------------------------

function unilib.get_init_biome_msg()

    -- Produces a message, used by init.lua, to show the number of biomes specified by each remix
    --      in their optional biome CSVs
    --
    -- Return values:
    --      The message to display in the chat window (an empty string if no biome tables were
    --          loaded)

    local msg = ""

    for _, remix_name in ipairs(unilib.remix_list) do

        if unilib.remix_biome_count_table[remix_name] ~= nil then

            msg = msg .. " " .. remix_name .. " "
            msg = msg .. "[" .. tostring(unilib.remix_biome_count_table[remix_name]) .. "]"

        end

    end

    return msg

end

function unilib.get_init_deco_msg()

    -- Produces a message, used by init.lua, to show the number of decorations specified by each
    --      remix in their optional decoration CSVs
    --
    -- Return values:
    --      The message to display in the chat window (an empty string if no decoration tables were
    --          loaded)

    local msg = ""

    for _, remix_name in ipairs(unilib.remix_list) do

        if unilib.remix_deco_count_table[remix_name] ~= nil then

            msg = msg .. " " .. remix_name .. " "
            msg = msg .. "[" .. tostring(unilib.remix_deco_count_table[remix_name]) .. "]"

        end

    end

    return msg

end

function unilib.get_init_ore_msg()

    -- Produces a message, used by init.lua, to show the number of ore specified by each remix in
    --      their optional ore CSVs
    --
    -- Return values:
    --      The message to display in the chat window (an empty string if no ore tables were loaded)

    local msg = ""

    for _, remix_name in ipairs(unilib.remix_list) do

        if unilib.remix_ore_count_table[remix_name] ~= nil then

            msg = msg .. " " .. remix_name .. " "
            msg = msg .. "[" .. tostring(unilib.remix_ore_count_table[remix_name]) .. "]"

        end

    end

    return msg

end

function unilib.get_init_pkg_msg()

    -- Produces a message, used by init.lua, to show the number of packages specified by each remix
    --
    -- Return values:
    --      The message to display in the chat window (an empty string if no remixes found)

    local msg = ""

    for _, remix_name in ipairs(unilib.remix_list) do

        msg = msg .. " " .. remix_name .. " "
        msg = msg .. "[" .. tostring(unilib.remix_pkg_count_table[remix_name]) .. "]"

    end

    return msg

end

