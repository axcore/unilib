---------------------------------------------------------------------------------------------------
-- unilib mod by A S Lewis, incorporating materials from many other mods
---------------------------------------------------------------------------------------------------
-- pbiomes_base.lua
--      Set up shared functions for creating pseudo-biomes
---------------------------------------------------------------------------------------------------

local S = unilib.intllib

-- From underch/worldgen.lua. Any package creating pseudo-biomes must enable the "stone_ordinary"
--      package
local c_stone = nil
local c_cobble = nil
local c_mossycobble = nil
local c_cobblestair = nil

---------------------------------------------------------------------------------------------------
-- Notes
---------------------------------------------------------------------------------------------------

-- Adapted from the regular version of the "underch" mod, which creates a number or underground
--      biomes, named "pseudo-biomes" in unilib code
-- For an example of how to create pseudo-biomes, see the "mapgen_underch" package
-- As in the original mod, code in this file is inadequately documented

---------------------------------------------------------------------------------------------------
-- Shared variables (used in perlin noise)
---------------------------------------------------------------------------------------------------

-- Tables used in perlin noise
unilib.pbiomes.np_darkness = {
    octaves = 3,
    offset = 0,
    persist = 0.5,
    scale = 1,
    seed = 6830,
    spread = {x = 200, y = 200, z = 200},
}

unilib.pbiomes.np_water = {
    octaves = 3,
    offset = 0,
    persist = 0.5,
    scale = 1,
    seed = 6831,
    spread = {x = 200, y = 200, z = 200},
}

unilib.pbiomes.np_pressure = {
    octaves = 3,
    offset = 0,
    persist = 0.5,
    scale = 1,
    seed = 6832,
    spread = {x = 200, y = 200, z = 200},
}

---------------------------------------------------------------------------------------------------
-- Shared functions (get values)
---------------------------------------------------------------------------------------------------

function unilib.pbiomes.get_pressure(h, r)

    -- Adapted from underch/functions.lua, underch.functions.get_pressure()
    --
    -- The pseudo-biome for any node depends on three values: darkness, water and pressure
    -- This function returns the pressure value for a particular node index> The range of possible
    --      values is unknown
    --
    -- Args:
    --      h (int): Height coordinate
    --      r (float): Number generated by the perlin noise generator for this particular node index
    --
    -- Return values:
    --      The pressure value

    local x = h / -1000
    r = r + 1

    -- Some pre-calculated magic numbers
    local top = -0.5 + (x + 1.0) *
        (0.1388888889 + (x - 0.2) *
            (-0.01543209878 + (x - 2.0) *
                (0.0006921306369 + (x - 12.0) *
                    (-0.00001692713955 + (x - 20.0) *
                        (1.781544043E-7 + (x - 25.0) *
                            2.521866255E-9
                        )
                    )
                )
            )
        )

    local bottom = -0.5 + (x + 1.0) *
        (0.08333333335 + (x - 1.0) *
            (-0.005892255893 + (x - 10.0) *
                (0.0002759423812 + (x - 20.0) *
                    (-0.000008676346390 + (x - 25.0) *
                        (1.290608758E-7 + (x - 32.0) *
                            6.980982443E-9
                        )
                    )
                )
            )
        )

    -- Return avg + r*dist
    return (r * top + (1 - r) * bottom) * 2

end

function unilib.pbiomes.get_biome(darkness, water, pressure)

    -- Adapted from underch/functions.lua, underch.functions.get_biome()
    --
    -- The pseudo-biome for any node depends on three values: darkness, water and pressure
    -- This function returns an integer in the range 0-61, representing the 62 biomes in the underch
    --      mod
    -- Note that there are four levels: 0-47 have equal weighting, the others occur progressively
    --      deeper
    --
    -- Args:
    --      darkness (float): Range of possible values unknown
    --      water (float): Range of possible values unknown
    --      pressure (float): Range of possible values unknown
    --
    -- Return values:
    --      0-61

    darkness = math.min(math.max(darkness, -0.999), 0.999)
    water = math.min(math.max(water, -0.999), 0.999)
    pressure = math.floor(math.min(math.max((pressure + 1) * 3, 0), 5))

    -- Calculate the return value
    if pressure < 3 then

        darkness = math.floor((darkness + 1) * 2)
        water = math.floor((water + 1) * 2)
        return (pressure * 16) + (water * 4) + darkness

    elseif pressure == 3 then

        darkness = math.floor((darkness + 1) * 1.5)
        water = math.floor((water + 1) * 1.5)
        return 48 + (water * 3) + darkness

    elseif pressure == 4 then

        darkness = math.floor(darkness + 1)
        water = math.floor(water + 1)
        return 57 + (water * 2) + darkness

    else

        return 61

    end

end

---------------------------------------------------------------------------------------------------
-- Shared functions (node replacement)
---------------------------------------------------------------------------------------------------

function unilib.pbiomes.replace(vi, data, def1, def2)

    -- Adapted from underch/functions.lua, underch.functions.replace()
    -- See the "mapgen_underch" package for calling examples

    if data[vi] == def1 then
        data[vi] = def2
    end

end

function unilib.pbiomes.ore(vi, data, def1, def2, chance)

    -- Adapted from underch/functions.lua, underch.functions.ore()
    -- See the "mapgen_underch" package for calling examples

    if data[vi] == def1 and math.random() < chance then
        data[vi] = def2
    end
end

function unilib.pbiomes.on_floor(x, y, z, vi, area, data, def_floor, def1, def2, chance, alt)

    -- Adapted from underch/functions.lua, underch.functions.on_floor()
    -- See the "mapgen_underch" package for calling examples

    local bi = area:index(x, y - 1, z)

    if (data[bi] == def_floor or data[bi] == alt) and
            data[vi] == def1 and
            math.random() < chance then
        data[vi] = def2
    end

end

function unilib.pbiomes.in_floor(x, y, z, vi, area, data, def_floor, def1, def2, chance, alt)

    -- Adapted from underch/functions.lua, underch.functions.in_floor()
    -- See the "mapgen_underch" package for calling examples

    local bi = area:index(x, y + 1, z)

    if (data[vi] == def_floor or data[vi] == alt) and
            data[bi] == def1 and
            math.random() < chance then
        data[vi] = def2
    end

end

function unilib.pbiomes.on_floor_rr(
    x, y, z, vi, area, data, p2data, def_floor, def1, def2, chance, alt
)
    -- Adapted from underch/functions.lua, underch.functions.on_floor_rr()
    -- See the "mapgen_underch" package for calling examples

    local bi = area:index(x, y - 1, z)

    if (data[bi] == def_floor or data[bi] == alt) and
            data[vi] == def1 and
            math.random() < chance then

        data[vi] = def2
        p2data[vi] = math.floor(4 * math.random())

    end

end

function unilib.pbiomes.on_roof(
    x, y, z, vi, area, data, def_roof, def1, def2, chance, lastlayer, alt
)
    -- Adapted from underch/functions.lua, underch.functions.on_roof()
    -- See the "mapgen_underch" package for calling examples

    local bi = area:index(x, y + 1, z)

    if not lastlayer and
            (data[bi] == def_roof or data[bi] == alt) and
            data[vi] == def1 and
            math.random() < chance then
        data[vi] = def2
    end

end

function unilib.pbiomes.in_roof(
    x, y, z, vi, area, data, def_floor, def1, def2, chance, lastlayer, alt
)
    -- Adapted from underch/functions.lua, underch.functions.in_roof()
    -- See the "mapgen_underch" package for calling examples

    local bi = area:index(x, y - 1, z)

    if not lastlayer and
            (data[vi] == def_floor or data[vi] == alt) and
            data[bi] == def1 and
            math.random() < chance then
        data[vi] = def2
    end

end

function unilib.pbiomes.on_wall_f(
    x, y, z, vi, area, data, p2data, def_wall, def1, def2, chance, lastlayer, alt
)
    -- Adapted from underch/functions.lua, underch.functions.on_wall_f()
    -- See the "mapgen_underch" package for calling examples

    if data[vi] ~= def1 or math.random() > chance then
        return
    end

    local dirs = {}
    local dirs_c = 0

    if data[area:index(x, y - 1, z)] == def_wall or data[area:index(x, y - 1, z)] == alt then

        dirs[dirs_c] = 0
        dirs_c = dirs_c + 1

    end

    if data[area:index(x, y, z - 1)] == def_wall or data[area:index(x, y, z - 1)] == alt then

        dirs[dirs_c] = 4
        dirs_c = dirs_c + 1

    end

    if data[area:index(x, y, z + 1)] == def_wall or data[area:index(x, y, z + 1)] == alt then

        dirs[dirs_c] = 8
        dirs_c = dirs_c + 1

    end

    if data[area:index(x - 1, y, z)] == def_wall or data[area:index(x - 1, y, z)] == alt then

        dirs[dirs_c] = 12
        dirs_c = dirs_c + 1

    end

    if data[area:index(x + 1, y, z)] == def_wall or data[area:index(x + 1, y, z)] == alt then

        dirs[dirs_c] = 16
        dirs_c = dirs_c + 1

    end

    if (data[area:index(x, y + 1, z)] == def_wall or data[area:index(x, y + 1, z)] == alt) and
            not lastlayer then

        dirs[dirs_c] = 20
        dirs_c = dirs_c + 1

    end

    if dirs_c == 0 then
        return
    end

    data[vi] = def2
    p2data[vi] = dirs[math.floor(dirs_c * math.random())] + math.floor(4 * math.random())

end

function unilib.pbiomes.on_wall_w(
    x, y, z, vi, area, data, p2data, def_wall, def1, def2, chance, lastlayer, alt
)
    -- Adapted from underch/functions.lua, underch.functions.on_wall_w()
    -- See the "mapgen_underch" package for calling examples

    if data[vi] ~= def1 or math.random() > chance then
        return
    end

    local dirs = {}
    local dirs_c = 0

    if (data[area:index(x, y + 1, z)] == def_wall or data[area:index(x, y + 1, z)] == alt) and
            not lastlayer then

        dirs[dirs_c] = 0
        dirs_c = dirs_c + 1

    end

    if data[area:index(x, y - 1, z)] == def_wall or data[area:index(x, y - 1, z)] == alt then

        dirs[dirs_c] = 1
        dirs_c = dirs_c + 1

    end

    if data[area:index(x + 1, y, z)] == def_wall or data[area:index(x + 1, y, z)] == alt then

        dirs[dirs_c] = 2
        dirs_c = dirs_c + 1

    end

    if data[area:index(x - 1, y, z)] == def_wall or data[area:index(x - 1, y, z)] == alt then

        dirs[dirs_c] = 3
        dirs_c = dirs_c + 1

    end

    if data[area:index(x, y, z + 1)] == def_wall or data[area:index(x, y, z + 1)] == alt then

        dirs[dirs_c] = 4
        dirs_c = dirs_c + 1

    end

    if data[area:index(x, y, z - 1)] == def_wall or data[area:index(x, y, z - 1)] == alt then

        dirs[dirs_c] = 5
        dirs_c = dirs_c + 1

    end

    if dirs_c == 0 then
        return
    end

    data[vi] = def2
    p2data[vi] = dirs[math.floor(dirs_c * math.random())]

end

---------------------------------------------------------------------------------------------------
-- Shared functions (setup biomes)
---------------------------------------------------------------------------------------------------

function unilib.pbiomes.setup(biome_table)

    -- Adapted from underch/worldgen.lua
    --
    -- Can be called by any package to set up pseudo-biomes
    -- See the "mapgen_underch" package for calling examples
    -- Any package creating pseudo-biomes must enable the "stone_ordinary" package
    --
    -- Args:
    --      biome_table (table): A table with keys in the range 1-62, with corresponding values
    --          which are a function to be called, every time the mapgen generates a block

    core.register_on_generated(function(minp, maxp, seed)

        -- Called after generating a piece of world
        -- minp/maxp encompasses a 5x5x5 volume of map blocks (80x80x80 nodes)
        -- Modifying nodes is a lot faster if voxel manipulation is used

        -- Apply the pseudo-biome upper limit (which should be the bottom of a Minetest map block,
        --      e.g. y=-192, or the top of the world, i.e. y=31000)
        if minp.y >= unilib.global.pseudo_biome_limit then
            return
        end

        -- Easy reference to commonly used values
        local x1 = maxp.x
        local y1 = maxp.y
        local z1 = maxp.z
        local x0 = minp.x
        local y0 = minp.y
        local z0 = minp.z

        -- A mapgen object is a construct used in map generation
        -- Get the VoxelManip object (as userdata), minimum and maximum emerged position (as a
        --      table)
        local vm, emin, emax = core.get_mapgen_object("voxelmanip")
        -- Create the helper class for voxel areas
        local area = VoxelArea:new{MinEdge=emin, MaxEdge=emax}
        local data = vm:get_data()
        local p2data = vm:get_param2_data()

        -- Mandatory values
        -- Length of a mapblock
        local sidelen = x1 - x0 + 1
        -- Table of chunk edges
        local chulens = {x = sidelen, y = sidelen, z = sidelen}
        local chulens2D = {x = sidelen, y = sidelen, z = 1}
        -- Bottom corner
        local minposxyz = {x = x0, y = y0, z = z0}
        -- 2D bottom corner
        local minposxz = {x = x0, y = z0}

        -- core.get_perlin_map() is a fast, bulk perlin noise generator
        -- Use it to get values for darkness, water and pressure, the three values used to determine
        --      the pseudo-biome
        local nvals_darkness =
            core.get_perlin_map(unilib.pbiomes.np_darkness, chulens):get_3d_map_flat(minposxyz)
        local nvals_water =
            core.get_perlin_map(unilib.pbiomes.np_water, chulens):get_3d_map_flat(minposxyz)
        local nvals_pressure =
            core.get_perlin_map(unilib.pbiomes.np_pressure, chulens):get_3d_map_flat(minposxyz)

        -- 3D node index
        local nixyz = 1
        -- 2D node index
        local nixz = 1
        -- Second 3D index for second loop
        local nixyz2 = 1

        -- For each xy plane progressing northwards
        for z = z0, z1 do

            -- Increment indices
            nixyz = nixyz + 1

            -- For each x row progressing upwards
            for y = y0, y1 do

                local vi = area:index(x0, y, z)

                -- For each node
                for x = x0, x1 do

                    -- Decide which pseudo-biome applies to this position
                    local darkness = nvals_darkness[nixyz2]
                    local water = nvals_water[nixyz2]
                    local pressure = unilib.pbiomes.get_pressure(y, nvals_pressure[nixyz2])
                    local biome = unilib.pbiomes.get_biome(darkness, water, pressure) + 1

                    if biome < 1 or biome > #biome_table then

                        unilib.utils.show_warning(
                            "../lib/shared/pbiomes/pbiomes_base.lua: Invalid pseudo-biome", biome
                        )

                        biome = 1

                    end

                    -- Call the node-conversion function for this pseudo-biome
                    biome_table[biome](x, y, z, vi, data, p2data, area, y == y1)

                    nixyz2 = nixyz2 + 1
                    nixz = nixz + 1
                    vi = vi + 1

                end

                --Shift the 2D index back
                nixz = nixz - sidelen

            end

            -- Shift the 2D index up a layer
            nixz = nixz + sidelen

        end

        -- Send data back to VoxelManip
        vm:set_data(data)
        vm:set_param2_data(p2data)
        -- Calculate lighting
        vm:set_lighting({day = 0, night = 0})
        vm:calc_lighting()
        -- Write it to world
        vm:write_to_map(data)

    end)

end
